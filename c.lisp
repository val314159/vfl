(defpackage :c (:use :cl :p) (:nicknames :core)
	    (:export #:pr #:prn #:fmt #:sfmt  #:peekc #:readc #:readp
		     #:^^ #:len #:call #:recurse #:rcall #:rrecurse
		     #:mv-bind #:mv-list #:=== #:!=== #:if? #:if! #:ife))
(in-package :c)
(defmacro mv-list(&rest $*)   (list* 'cl:multiple-value-list $*))
(defmacro mv-bind(&rest $*)   (list* 'cl:multiple-value-bind $*))
(defmacro ^^ (&rest _*)       (list* 'cl:values _*))
(defmacro if?  ($1 &rest $*)  (list* 'cl:when   $1 $*))
(defmacro if!  ($1 &rest $*)  (list* 'cl:unless $1 $*))
(defmacro  === ($1 $2)        (list  'cl:eq  $1 $2   ))
(defmacro !=== ($1 $2) (list 'cl:not (list 'cl:eq $1 $2)))
(defmacro ife (&rest _*)
  (list* 'cl:cond (rrecurse _* (位 (f x)
				  (cl:case (len x)
				    (0)
				    ((1 2) (list x))
				    (T (list* (list (:0 x) (:1 x))
					      (recurse f (:2+ x)))))))))
(defvar nl-pos 0)
(defun update-nl (_)        (cl:setf nl-pos (file-position _)))
(defun offset-nl (_)        (cl:- (file-position _) nl-pos))
(defun len (_)              (cl:length _))
(defun  pr (_ &optional _2) (cl:princ _ _2) (cl:princ " " _2) _)
(defun  prn(_ &optional _2) (cl:princ _ _2) (cl:terpri    _2) _)
(defun  fmt  (&rest     _*) (cl:apply #'cl:format cl:t   _*))
(defun sfmt  (&rest     _*) (cl:apply #'cl:format cl:nil _*))
(defun peekc (&optional  _) (cl:peek-char nil _ nil eof))
(defun readc (&optional  _)
  (let ((c (cl:read-char _ nil eof)))
    (if? (cl:eq c #\Newline) (update-nl _))
    c))
(defun readp (&optional  _) (cl:read-preserving-whitespace _ nil eof))
(defun odds  (_) (cl:loop :for e :in _ :by #'cl:cddr :collect e))
(defun evens (_) (odds (cdr _)))
(defun samep (_) (= 1 (len (cl:remove-duplicates _))))
(defun call  (_ &rest _*) (cl:apply #'cl:funcall _   _*))
(defun recurse  (_ &rest _*) (cl:apply #'cl:funcall _ _ _*))
(defun rcall    (_ $f) (call $f _))
(defun rrecurse (_ $f) (recurse $f _))
(set-macro-character #\} (位 (% %2) (error "}")))
(set-macro-character
 #\{ (位 (_ &optional %2)
	(let((x (cl:read-delimited-list #\} _)))
	  (cl:case (len x)
	    (0 undef)
	    (1 (:L 'cl:values (:0 x)))
	    (2 (:L (:0 x) (:1 x)))
	    (T (cl:cond ((evenp (len   x)) (error "even args"))
			((samep (evens x)) (:L* (:1 x) (odds x)))
			(cl:t              (error "op mismatch"))))))))
(set-macro-character #\  (位 (_ %) (:L 'macroexpand-1 (:L 'quote (rpws _)))))

