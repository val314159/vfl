(in-package :r)
(:$ *bl* := (:0 "•"))
(:$ *lm* := (:0 "λ"))
(:$ *cm* := (:0 ","))
(:$ *ct* := (:0 "^"))
(:$ *em* := (:0 "!"))
(:$ *sm* := (:0 ";"))
(:$ *op* := (:0 "("))
(:$ *cp* := (:0 ")"))
(:$ *os* := (:0 "["))
(:$ *cs* := (:0 "]"))
(:$ *ob* := (:0 "{"))
(:$ *cb* := (:0 "}"))
(:$ *ap* := (:0 "'"))
(:$ *cl* := (:0 ":"))
(:$ *dq* := (:0 "\""))
(:$ *bs* := (:0 "\\"))
(:$ *sl* := (:0 "/"))
(:$ *ot* := (:0 "#"))
(:$ *sp* := (:0 " "))
(:$ *tb* := (:0 "	"))
(:$ *nl* := (name-char "newline"))
(:$ *cr* := (name-char "return"))
(:$ *ws* := (list *tb* *sp* *cr* *nl*))
(:$ *wc* := (list *tb* *sp* *cr*))

(defun sym-char-p (c)
  (mv-bind (m n) (get-macroc c) (if3 m n #t)))

(defun intern-sym (str pkg)
  (if3 (find *cl* str) (error "extra colons in ~a:~a" pkg str)
       (handler-case (if3 (> (len pkg) 0) (intern str pkg)
			  (^^             (intern str "KEYWORD")))
	 (error ()                        (intern str pkg)))))

(defun convert-symbol (str)
  (if3 (is (elt str 0) *cl*)
       (intern-sym (subseq str 1) "")
       (handler-case (parse-integer str)
	 (error ()
	   (let ((pos (position *cl* str)))
	     (if3 pos (intern-sym (subseq str (1+ pos))
				  (subseq str  0  pos))
		  (^^ (intern-sym str *package*))))))))

(defun read-sym (&optional s)
  (handler-case
      (if3 (is (peekc s) *bs*) (@@ (readc s)
				   (cons (readc s) (read-sym s)))
	   (if2 (sym-char-p (peekc s)) (cons (char-upcase (readc s))
					     (read-sym s))))
    (end-of-file () #f)))

(defun read-str (e &optional s)
  (handler-case
      (if3 (is (peekc s) *bs*) (@@ (readc s)
				   (cons (readc s) (read-str e s)))
	   (if3 (is (peekc s) *dq*) (if1 (readc s))
		(cons (readc s) (read-str e s))))))

(defun read-ws (&optional s)
  (handler-case
      (if2 (find (peekc s) *ws*) (cons (readc s) (read-ws s)))
    (end-of-file () #f)))

(defun read-wc (&optional s)
  (handler-case
      (if2 (find (peekc s) *wc*) (cons (readc s) (read-ws s)))
    (end-of-file () #f)))

(defun read-string (&optional s c)
  (concat-string (read-str c s)))

(defun read-symbol (&optional s c)
  (convert-symbol (concat-string (cons (char-upcase c) (read-sym s)))))

(defun read-expr (&optional s)
  (read-ws s)
  (let* ((c (readc s))
	 (m (get-macroc c)))
    (if3 m (call m s c)
	 (read-symbol s c))))

(defun xload-stream (&optional s)
  (handler-case (@@ (eval (macroexpand (read-expr s)))
		    (load-stream s))
    (end-of-file () #f)))

(defun load-stream (&optional s)
  (handler-case (let* ((a (read-expr s))
		       ;;(x (fmt "I:[~s]" a))
		       (b (macroexpand a))
		       ;;(y (fmt "M:[~s]" b))
		       (c (eval b))
		       ;;(z (fmt "O:[~s]" c))
		       )
		  (load-stream s))
    (end-of-file () #f)))

(defun load-file2 (filename)
  (let ((*load-pathname* (pathname filename)))
    (with-open-file (stream filename)
      (load-stream stream))))

(defun load-file (filename)
  (let ((*load-pathname* (pathname filename)))
    (with-open-file (stream (concatenate 'string filename ".lisp"))
      (load-stream stream))))

(defun read-character (s c)
  (declare (ignore c))
  (if3 (is (peekc s) *bs*) (readc s)
       (let* ((sym  (read-sym s))
	      (slen (len sym)))
	 (cond ((= slen 0) (readc s))
	       ((= slen 1) (car sym))
	       (#t (let* ((name (concat-string sym))
			  (result (name-char name)))
		     (ifn result (error "bad char name: ~a" name))
		     result))))))

(defun read-dlist (e &optional s)
  (read-ws s)
  (if3 (is (peekc s) e) (if1 (readc s))
       (let* ((v (mv-list (read-expr s)))
	      (c (peekc s)))
	 (if3 (is c #\()
	      (let* ((y (read-expr    s))
		     (x (read-dlist e s)))
		(cons (cons (car v) y) x))
	      (let* ((x (read-dlist e s)))
		(if3 v (cons (car v) x) x))))))

(defun qread-dlist (e &optional s)
  (read-ws s)
  (if3 (is (peekc s) e) (if1 (readc s))
       (let* ((v (mv-list (read-expr s)))
	      (c (peekc s))
	      (x (read-dlist e s)))
	 (if2 (is c #\() (fmt "~a:~a:errorrrr" *load-pathname* (file-position s)))
	 (if3 v (cons (car v) x) x))))

;;(defun read-delimited-list (e &optional s)
;;  (read-dlist (e s)))

(:$ *infix-ops* := (q (cl:list)))

(defun infix (x)
  (case (len x)
    (0  (error "zero args"))
    (1  (cons (q ^^) x))
    (2  (if (find (:1 x) *infix-ops*)
	    (list (:1 x) (:0 x))
	    (list (:0 x) (:1 x))))
    (4  (list (:1 x) (:0 x) (:2 x) (:3 x)))
    (#t (cond ((evenp (len   x)) (error "even args"))
	      ((samep (evens x)) (cons (:1 x) (odds x)))
	      (#t                (error "op mismatch"))))))

(defun read-line (&optional s (eof-error-p #t) eof-value)
  (read-next-line s eof-error-p eof-value))

(defun read-stream (s &optional (line (read-next-line s #f #f #t)))
  (if2 line (cons line (read-stream s))))

(defun install-macro-chars ()
  (set-macroc *cm* (λ (s c) (q cl:list)))
  (set-disp-macroc *ot* *lm* (λ (s c d) (list funct (read-expr s))))
  (mapcar (λ (x) (set-macroc x (λ (s c) (^^)))) *ws*)
  (set-macroc *bs* (function read-character))
  (set-disp-macroc *ot* *bs*  (λ (s c d) (read-character s d)))
  (set-macroc *cs* (λ (s c) (error "X")))
  (set-disp-macroc *ot* *os*  (λ (s c d) (cons (q list) (read-dlist *cs* s))))
  (set-macroc *dq* (function read-string))
  (set-macroc *sm* (λ (s c) (^^ (read-line s))))
  (set-macroc *op* (λ (s c) (read-dlist *cp* s)))
  (set-macroc *cp* (λ (s c) (error "X")))
  (set-macroc *ob* (λ (s c) (infix (read-dlist *cb* s))))
  (set-macroc *cb* (λ (s c) (error "X")))
  (set-macroc *ap* (λ (s c) (list quot (read-expr s))))
  (set-disp-macroc *ot* *sl* (λ (s c d)
				(list quot (read-expr s))))
  (set-disp-macroc *ot* *ct* (λ (s c d)
				(list quot (read-expr s))))
  (set-macroc *em* (λ (s c)
		      (list (q not) (read-expr s)))
	      cl:t)
  (set-macroc *bl* (λ (s c) (values))))

(defun syntax2 ()
  (set-macroc *os* (λ (s c) (read-dlist *cs* s)))
  (set-macroc *op* (λ (s c) (infix (read-dlist *cp* s)))))

(export-package)
